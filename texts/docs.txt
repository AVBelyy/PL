Сей документ содержит набор важной информации по компилятору, интерпретатору
и синтаксису языка. Текст является скорее набором идей, чем чёткой структурой.
По мере развития проекта постараюсь сортировать мысли, находящиеся здесь,
в разные категории и подкатегории.

(C) Anton Belyy, 2011. All rights reserved!!!




Заметка №0. Хозяйке на заметку.
Date:	Jan 1 1970
Music:	/dev/urandom
Content:

Так получилось, что проект пока не имеет названия.
Поэтому вместо названия будет употребляться слово ПРОЕКТ (заглавными буквами).
ПРОЕКТ - это общее название компилятора, интерпретатора и языка программирования.
Запомнили? :) Тогда можете смело переходить к чтению заметок.



Заметка №1. О первом прерывании или INT 0x01.
Date:	Feb 6 2011
Music:	Jean Michel Jarre - Oxygene IV
Content:

Первая заметка описывает механизм прерываний в целом и структуру прерывания №1.
Прерывание (Interrupt) в ПРОЕКТЕ - это вызов определённых процедур интерпретатора
с передачей параметров. Прерывание является платформо-зависимым механизмом,
так как каждый интерпретатор в праве определять свой набор прерываний.
Тем не менее, первые 16 прерываний зарезервированы для общих нужд, таких как:
получение версии интерпретатора, платформы, на которой работает интерпретатор,
времени и даты, и так далее.
Каждое прерывание имеет номер, являющийся натуральным числом от 1 до 16384.
"Общение" с обработчиком прерывания ведётся при помощи регистров [2].
Обработчик прерывания читает значение из регистра и возвращает ответ в регистр.
Некоторые обработчики также работают с памятью процесса [3], тогда требуется
передать через регистр ссылку на нужный блок памяти.
Одно прерывание может выполнять одновременно несколько фукнций. В этом случае
в регистре R0 передаётся номер функции.
Прерывание №1 предоставляет информацию о интерпретаторе и платформе (имеется ввиду
платформа, на которой работает интерпретатор - например AVR, ARM или x86)
В дальнейшем все прерывания будут описываться следующим образом:
	INT НомерПрерывания, R0 = НомерФункции
	[Вход: значения регистров]
	[Выход: значения регистров]
	[Краткое описание функции]
Такой же синтаксис для описания прерывания используется в книге Зубкова
"Assembler для DOS, Windows и UNIX", которая оказала меня большое влияние.
Опишем теперь функции прерывания №1:

	INT 0x01, R0 = 1: Узнать платформу, на которой работает интерпретатор
	Выход:
		R0: идентификатор
	Идентификатор является целым числом. Чтобы узнать название платформы,
	воспользуйтесь указанной ниже таблицей:
	------------------
	| ID | Платформа |
	------------------
	| 1  | Atmel AVR |
	| 2  | Win32     |
	| 3  | UNIX      |
	| 4  | DOS       |
	------------------
	
	INT 0x01, R0 = 2: Узнать версию интерпретатора
	Выход:
		R0: номер версии в специальном формате
	Номер версии является целым числом в формате XXYZZ.
	Таким образом, для версии 1.4.32 в R0 будет содержаться число 01432.
	
Первая заметка получилась довольно насыщенной. Надеюсь, после её прочтения
механизм прерываний в ПРОЕКТЕ вам стал понятен. Приятного кодинга!

Заметка №2. Поговорим о регистрах.
Date:	Feb 6 2011
Music:	Tanzwut - Niemals Ohne Dich
Content:

Так получилось, что в первой заметке используются термины, относящиеся к ПРОЕКТУ,
но вряд ли понятные кому-то кроме меня :) Чтобы исправить это недоразумение и
поближе познакомить тебя со структурой ПРОЕКТА, предлагаю познакомиться с ещё
одной языковой структурой - регистрами.
Что же это такое? Если коротко, то unsigned short regs[10] :)
Для тех, кто ещё почему-то не выучил Си: регистры - это беззнаковые целые
переменные, которые могут принимать значение от 0 до 65535. Регистров ровно 10 штук,
все имеет одно назначение: передавать числовые данные в процедуры и
обработчики прерывания. Чтобы присвоить значение регистру, используйте команду
MOV Rn value, где n - номер регистра. Когда нужно последовательно присвоить значение
нескольким регистрам (например, от R0 до R4), можно использовать команду PUSH:
PUSH 24				// MOV R0 24
PUSH MyVar			// MOV R1 MyVar
PUSH R1				// MOV R2 R1
PUSH "Test str"		// MOV R3 "Test str"
PUSH &Buffer		// MOV R4 &Buffer
INT 0x13

Вот и всё, что я хотел рассказать о регистрах. Если после прочтения заметки
что-то осталось непонятным - читайте её снова и снова :)



Заметка №3.	PRAM, память процесса.
Date:	Feb 6 2011
Music:	что-то там играет
Content:

Ещё кое-что интересное и непонятное для вас из заметки №1.
Но об этом завтра, на сегодня с вас хватит.



Заметка №4. Поразмышляем над остальными прерываниями.
Date:	Feb 6 2011
Music:	Megaherz - Mach Dich Frei
Content:

С первым всё понятно. Давайте придумаем назначение остальных 16383 прерываний.
Пусть эта заметка будет изменяемой. По мере появления идеи будут заноситься
сюда и ни в коем случае не будут удаляться. Плохая идея - тоже идея, верно?

ACHTUNG: Приготовьтесь к обилию технического сленга и непонятных сокращений.
А лучше прямо сейчас прекратите читать заметку, ибо это не заметка, а draft,
где на ваших глазах рождаются стандарты языка. Здесь вы ничего нового не узнаете.
Короче, это write-only (пока не наберётся достаточное кол-во текста) заметка.
Если считаете, что ваши мысли кому-то интересны, пишите их здесь. Читать чужой текст
здесь крайне не рекомендуется. Всё, довольно словоблудий. Переходим к делу.

INT 0x02: инфа о процессе:
	- размер data-секции (вы всё ещё читаете? ок. о секциях смотрим в заметке 5)
	- PID для приложений и динамических библиотек (см. заметку 6)
	- ???
	- PROFIT!
	
INT 0x05: консольное I\O
	Вообще, сюда можно отнести ведь ввод-вывод, не только консольный.
	Для AVR-ок это вывод символов, рисование прямоугольничков,
	для Win32 и UNIX-интров - рисование графических примитивов вроде окон и кнопок.
		Или не? Может пока не заморачиваться с окнами и прочем ГУЁм?
	Идея: часть функций сделать платформо-независимыми (создание консольного окна,
	вывод символов), а кнопочки-рамочки вынести в прерывание № > 16.
	Итак, функции:
		- #1: общая функция для изменения параметров окна (высота, ширина, цвет и т.д.)
		- #2: получение информации о графической подсистеме
			* R1 = 1: поддерживается ли графический режим?
				Вывод: R0=1 - да, R0=0 - нет
			* R1 = 2: получить параметры экрана (если поддерживается графический режим)
				Вывод: R0 - ширина, R1 - высота, R2 - кол-во цветов (см. таблицу)
				----------------------
				| R3 | Кол-во цветов |
				----------------------
				| 1  |       2       |
				| 2  |      16       |
				| 3  |      256      |
				| 4  |     4096      |
				| 5  |     65536     |
				| 6  |   16777216    |
				----------------------

		- #3: вывод символа (R1) в окно.
		- #4: вывод строки (R1) в окно.
		- #5: ввод текста с клавиатуры
			* R1 = 1: поддерживается ли ввод с клавиатуры?
				Вывод: R0=1 - да, R0=0 - нет
			* R1 = 2: прочитать символ с отображением
			* R1 = 3: прочитать символ без отображения 
				Вывод в обоих случаях: R0-ASCII-код символа
			* R1 = 4: узнать символ конца строки
				Вывод: R0-ASCII-код символа
		- рисование контролов в окне. здесь будет мало кода, потому как ГУЙ
		  сильно привязан к платформе (сказываются ограничения AVR и прочих МК)

INT 0x11: ncurses
	нестандартное прерывание, чтобы делать консольные красивости в UNIX\Win32\DOS.
	Функции:
		- #1: инициализация (initscr)
		- #2: деинициализация (endwin)
		- 
		

Заметка №5. Секции и процедуры.
Заметка №6. Подробнее о секции HEADER.


Заметка №7. PRAM, память процесса (продолжение).
Date:	Feb 7 2011
Music:	
Content:

